## 当前状态结论

* 查询阶段未实际使用变量别名。别名系统仅在`CmdManager::AnalysisCmd_ForTest`中初始化，但核心查询输出与调试均未读取别名。

* 证据：

  * `query/CmdManager.cpp:99-121` 初始化别名，但未在后续显示中使用。

  * `query/LogStore_API.cpp:78-89` 启动阶段的别名初始化被注释。

  * `query/LogStore_API.cpp:3966-3995` `FormatVarName()`中获取别名的逻辑被注释，始终返回原始ID格式。

  * 查询过程的变量名显示均依赖`FormatVarName()`，因此目前不会显示别名（如`query/LogStore_API.cpp:585-586`, `2261-2269`, `2348-2462`等）。

## 问题列表

* 别名系统初始化位置不统一（测试路径初始化，正式`BootLoader`未启用）。

* `FormatVarName()`未调用别名管理器，导致别名无效。

* CLI输出面向用户的路径主要依赖`Syslog*`打印，未统一走`FormatVarName()`的别名逻辑（现状多数走，但需确认齐全）。

## 修改计划

* 初始化统一到查询启动：

  1. 在`LogStoreApi::BootLoader`中启用别名系统：`VarAliasManager::getInstance()->initializeForZip(path + "/" + filename)`；并提供全局回退`initialize("var_alias.conf")`。
  2. 设置默认配置路径（可选）：在查询进程启动处为`VarAliasManager`设置`defaultConfigPath`，例如工作目录或`query/var_alias.conf`。

* 显示统一：

  1. 启用`FormatVarName()`中的别名读取：若存在别名则返回别名，否则回退原格式；保持现有位域格式化作为默认。
  2. 审核所有变量名输出调用统一使用`FormatVarName()`：重点检查`SyslogDebug/SyslogOut`的变量名打印处（如`AddSubPatternToMap`、`Search*InVar*`、`Materialization`相关日志）。

* 配置与健壮性：

  1. 路径解析：`initializeForZip()`当前生成`zipName + ".var_alias"`（`query/var_alias.h:77-85`），确保`Connect(logStorePath, fileName)`传递的`fileName`就是压缩文件名，能定位到`path/fileName.var_alias`。
  2. 线程安全：别名加载仅在启动时进行，查询期间只读；保持单例只读访问避免锁开销。
  3. 回退策略：若找不到特定配置，使用全局`var_alias.conf`；找不到任何配置则正常运行但显示原始ID。

* 命令行与工具（可选）：

  1. 在`CmdManager`或`ThuCmd`增加`alias reload`命令，调用`VarAliasManager::initialize...`以热重载。
  2. 在帮助文档中明确`path/file.var_alias`优先、`var_alias.conf`回退。

## 验证计划

* 单元测试：

  * 对`FormatVarName()`输入包含与不包含别名的ID，断言返回值分别为别名与原格式。

  * `BootLoader`加载时，构造`path/file.var_alias`与仅全局`var_alias.conf`两种场景，验证优先级与回退。

* 集成测试：

  * 使用`example_zip/Ssh`等压缩包，添加`*.var_alias`映射如`1_1.1=src.ip`，运行查询并观察调试输出与最终物化日志，确认别名出现。

## 风险与兼容

* 仅影响可读性层（显示），不改变存储与匹配逻辑；若配置缺失则无副作用。

